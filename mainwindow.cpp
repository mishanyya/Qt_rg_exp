#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "QRegExp" //для работы с регулярными выражениями


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    //editingFinished() - срабатывает при нажатии кнопки Enter или Return
    connect(ui->lineEdit, SIGNAL(editingFinished()), this, SLOT(inputTextInField())); //для ввода символов и проверки его содержимого через регулярные выражения


}

MainWindow::~MainWindow()
{
    delete ui;
}




void MainWindow::inputTextInField() //для ввода символов и проверки его содержимого через регулярные выражения
{
//чтобы не было лишних знаков сделать

QString str= ui->lineEdit->text(); // получаем значение QLineEdit

//Рабочие варианты:

//десятичное число с точкой
//QRegExp rx("\\d*\\.\\d+");

//цифры
//QRegExp rx("\\d+");

//цифра от 1 до 9, которая встречается не меньше одного (1) и не больше одного (1) раза
//QRegExp rx("[0-9]{1,1}");

//КРОМЕ цифр от 1 до 9, которые встречаюется не меньше одного (1) и не больше двух (2) раз,
//сработает только если введены указанные цифры, если их больше или встречаются другие символы, то не срабатывает!
//^-начало выражения, $-конец выражения
//QRegExp rx("^[0-9]{1,2}$");

//цифры от 0 до 9 могут быть заменены символом \\d и сработает как предыдущий пример
//любые знаки кроме цифр обозначаются \\D
//QRegExp rx("^\\d{1,2}$");
//QRegExp rx("^\\D{1,2}$");

//КРОМЕ цифр от 1 до 9, которые встречаюется не меньше одного (1) и не больше двух (2) раз,
//сработает только если введены указанные цифры, если их больше или встречаются другие символы, то не срабатывает!
//здесь есть начало выражения ^ поэтому срабатывает впереди должны быть только цифры, а в конце могут быть любые и ошибки не покажет
//QRegExp rx("^[0-9]{1,2}");
//Примечание: при использовании знака ^ в начале выражения он означает строго начало строки,
//а при использовании этого же знака, хотя бы правее он значит 'кроме'
//далее будет срабатывать на любые символы кроме цифр
//QRegExp rx("[^0-9]{1,2}");


//строго цифры в количестве от 0 до 1
//сработает даже при пустом значении, но не должно быть больше вообще никаких символов
//например с одной буквой не сработает!
//QRegExp rx("^\\d{0,1}$");
//{0,1} можно заменить вопросительным знаком ? и сработает также как предыдущий пример
//QRegExp rx("^\\d?$");
//можно поcтавить два знака \\d и после второго поставить ? - это будет означать первый знак \\d - точно и второй знак \\d - возможно
//то есть от 1 до 2 - {1,2}
//если число знаков не указано, то считается как 1
//QRegExp rx("^\\d\\d?$");

//слово

//QRegExp rx("слово");

//слово
//в этом выражении \\b означает переднюю и заднюю границы слова у одного или нескольких искомых слов 'word' или 'слово', или 'два слова'
//будет проверен ввод строго одного или другого слова! при этом через ПРОБЕЛ или ЗАПЯТУЮ в тексте могут быть написаны еще другие слова!
//скобки внутри () не одно из них, а все символы сразу, правда которые можно использовать по отдельности со знаком 'или' |
//знак | означает 'или' - будет искать слова 'word' или 'слово' среди всего текста
//QRegExp rx("\\b(word|слово|два слова)\\b");

//Знак точки '.' заменяет любой символ
//работает аналогично предыдущему, но вместо точки сработает одна любая буква или символ
//QRegExp rx("\\b(wo.d|сл.во|дв. слова)\\b");

//знак пробела обозначается \\s
//QRegExp rx("\\b(дв.\\sслова)\\b");
//любой знак, кроме пробела обозначается \\S
//QRegExp rx("\\b(дв.\\Sслова)\\b");

//символ \\w показывает только все буквы и цифры
//не работает со знаками пробел, запятая, точка, /?<>@+-*/ и другими
//QRegExp rx("\\w");

//символ \W	показывает все кроме букв и цифр
//QRegExp rx("\\W");

//Примечание
//обычно для обозначения спецсимволов нужен один backslash, но для C++ в Qt надо добавлять еще один такой знак
//а для обозначения самого знака backslash их надо вставить четыре (4) символа обратной косой черты


//каждую букву, необходимую для поиска надо перечислять в КВАДРАТНЫХ скобках полностью весь набор или через знак -
//в данном примере можно указать дополнительные другие символы кроме требуемых
//QRegExp rx("[а-в]{3}");
//сработает после ввода буквы 3 раза, но дополнительно еще можно будет ввести
//знак + после символа означает повторение символа один и более раз
//знак * после символа означает повторение символа ноль и более раз
//число в фигурных скобках {число} после символа означает точное количество таких знаков

//число в фигурных скобках до запятой {число,} после символа означает количество таких знаков от 'числа' включительно и более
//число в фигурных скобках после запятой {,число} после символа означает количество таких знаков от нуля до 'числа' включительно
//два числа в фигурных скобках после символа через запятую {число1,число2} означает количество таких знаков от 'числа1' до 'числа2'
//QRegExp rx("[а-в]{3}т{2}"); //уже получится 'слово ааатт'

//для email
//QRegExp rx("^([a-zA-Z0-9\\-\\_\\.]+\\@[a-z]+\\.[a-z]+)$");
//буквы латинские любого размера,цифры, знаки -_. повторяются один или более раз, затем знак @, затем строчные латинские
//буквы один или несколько раз, затем знак точки и опять строчные буквы один или несколько раз

//для ip
//QRegExp rx("^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$");

//телефонный номер в виде знака + и 11 цифр
//QRegExp rx("^\\+[0-9]{11}$");

//для даты
//QRegExp rx("^[1-3]?[0-9]\\.[0-1]?[0-9]\\.[0-9]?[0-9]?[0-9]?[0-9]$");

//url
//например https://doc.qt.io/qt-5/qregexp.html#details
//https://mail.ru/
//https://yandex.ru/
//https://v1.ru/
//https://zebrafitness34.ru/services/group-programms
QRegExp rx("^(http://|https://)?[\\w\\-]+([\\w\\-\\.\\/])*[\\.\\w]+\\/*(\\#[\\w\\-]+)?$");



//конец строки
//первое слово
//фио
//кроме букв
//русские символы
//верхний регистр
//номер автомобиля

//скобки
//поиск с конца
//до определенного символа
//первое вхождение
//разбить массив на слова
/*только цифры
только буквы
для email
для ip
телефонный номер
для даты
url
конец строки
первое слово
фио
кроме букв
русские символы
верхний регистр
номер автомобиля
слово
скобки
поиск с конца
до определенного символа
первое вхождение

Найти это выражение в тексте и указать на него
найти лишние символы
собрать в массив все слова, разделенные знаками, например запятыми
собрать все слова по определенному признаку
собрать в массив все слова, которые находятся в скобках

qwertyвыражение12345
проверить наличие такого выражения и сохранить его
проверить наличие выражения и сообщить о лишних символах*/

//QRegExp rx("\\s");                    //знак пробела
//QRegExp rx("\\@\\.[0-9]");            //набор знаков @. и одной из цифр, например @.6
//QRegExp rx("[a-zA-Z]");               //любой символ от a до Z любого регистра, например h или H
//QRegExp rx("[^a-z]");                 //любой символ кроме от a до z, например 4
//QRegExp rx("[^\\@\\_\\-\\.a-zA-Z0-9]"); //любой символ кроме @ _ – . или букв и цифр - от a до z, A-Z, 0-9, например <
//QRegExp rx("[^a-z+]");                    //любой символ кроме от a до z, например 5
//QRegExp rx("[^(a-z0-9)+]");                 //любой символ кроме от a до z или от 0 до 9 и знака +, например =
//QRegExp rx("[^(a-zA-Z0-9)+\\@]");            //любой символ кроме от a до z или от A до Z или от 0 до 9 и кроме @ и знака +, например /




//rx.indexIn(str); // возвращает номер первого символа от группы значений найденного совпадения, начиная с 0
//если нет совпадений показывает -1
QString a,b;
a="Есть такое значение в строке!";
b="НЕТ таких значений!";

if(rx.indexIn(str)!=-1){
    ui->label->setText(a);
}
else{
    ui->label->setText(b);
}


/*
 * //rx.pos(0);  // возвращает номер первого символа найденного совпадения
QRegExp rx("\\s");//значение, которое ищет регулярное выражение в строке - знак пробела

//QStringList list;//массив с символами
QList<QString> list;//массив с символами
int pos = 0;
//разбить строку на элементы и поместить в массив
while ((pos = rx.indexIn(str, pos)) != -1) {
    list << rx.cap(1);
    pos += rx.matchedLength();
}
// list: ["12", "14", "99", "231", "7"]
*/

 /*
 QList<int>  allValues;//массив всех значений типа int
  for (int q=1;q<91;q++ ) {
      allValues << q;
  }
    QStringList values;
    QString entireValue;
*/


}

